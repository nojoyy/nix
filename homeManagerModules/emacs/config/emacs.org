#+TITLE: New Emacs Config
#+AUTO_TANGLE: t
#+PROPERTY: header-args:emacs-lisp :tangle ./init.el 

* Early Init
Set early init vars for straight.el
#+begin_src emacs-lisp :tangle ./early-init.el
(setq package-enable-at-startup nil)
#+end_src

* Package Management
Package Management via straight.el
#+begin_src emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name
      	"straight/repos/straight.el/bootstrap.el"
    	(or (bound-and-true-p straight-base-dir)
  	    user-emacs-directory)))
        (bootstrap-version 7))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
  	(url-retrieve-synchronously
  	 "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
  	 'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  ;; Set up use-package to use straight.el
  (straight-use-package 'use-package)
  (setq straight-use-package-by-default t)
#+end_src


* Evil Mode
Vi emulation layer. Adds vim emulation to emacs in all programming and text editing buffers. Evil collection is a collection of keybind packages designed to integrate vim keybinds into popular emacs packages such as magit.
#+begin_src emacs-lisp
  (use-package evil
    :hook ((prog-mode text-mode) . display-line-numbers-mode)
    :custom
    (display-line-numbers-type 'relative)
    (evil-want-integration t)
    (evil-want-keybinding nil)
    (evil-want-C-i-jump nil)
    (evil-respect-visual-line-mode t)
    (evil-want-Y-yank-to-eol t)
    :init
    (evil-mode))

  ;; Keybind collection for evil
  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))
#+end_src

** Undo/Redo
Implement undo redo for evil using undofu. This allows for undo branching and branch hopping if need be.
#+begin_src emacs-lisp
  (use-package evil
    :custom
    (evil-undo-system 'undo-fu))

  (use-package undo-fu
    :custom
    (undo-limit 67108864)
    (undo-strong-limit 100663296)
    (undo-outer-limit 1006632960))
#+end_src


* Keybinds
** General
Leader key definition and easy keybinds. I have defined a lot of various keybinds here that I don’t think belong anywhere else.
#+begin_src emacs-lisp
  (use-package general
    :config
    (general-evil-setup)

    (general-create-definer nj/leader-keys
      :states '(normal insert visual emacs)
      :keymaps 'override
      :prefix "SPC"
      :global-prefix "C-SPC")

    (nj/leader-keys
      "/" '(find-file :wk "goto file")
      ">" '(:ignore t :wk "goto")
      "> r" '(recentf :wk "goto recent file")
      "> m" '(bookmark :wk "goto bookmark")
      "f" '(:ignore t :wk "find")
      "f f" '(find-file :wk "find file")
      "f r" '(recentf :wk "find recent")
      "f m" '(bookmark :wk "find bookmark")
      "x" '(execute-extended-command :wk "M-x")
      "C-/" '(comment-line :wk "comment lines"))

    (nj/leader-keys
      "TAB" '(evil-window-next :wk "next window"))

    ;; buffer keybinds
    (nj/leader-keys
      "b" '(:ignore t :wk "buffer")
      "b b" '(counsel-switch-buffer :wk "switch to buffer")
      "b i" '(ibuffer :wk "ibuffer")
      "b k" '(kill-this-buffer :wk "kill buffer")
      "b n" '(next-buffer :wk "next buffer")
      "b p" '(previous-buffer :wk "previous buffer")
      "b r" '(revert-buffer :wk "reload buffer"))

    ;; bookmarks
    (nj/leader-keys
      "m" '(:ignore t :wk "bookmarks")
      "m d" '(bookmark-delete :wk "delete bookmark")
      "m l" '(bookmark-bmenu-list :wk "bookmark list")
      "m m" '(bookmark-set :wk "add bookmark")
      "m M" '(bookmark-set-no-overwrite :wk "add permanent bookmark"))) 
#+end_src

** Which-Key
Keybind tooltips
#+begin_src emacs-lisp
    (use-package which-key
      :diminish
      :init
      (which-key-mode 1)
      :custom
      (which-key-idle-delay 0.8)
      (which-key-allow-imprecise-window-fit nil))
#+end_src


* Completion
** Vertico
Completion interface, replacement for Ivy
#+begin_src emacs-lisp 
  (use-package vertico
    :ensure t
    :bind (:map vertico-map
  	      ("C-j" . vertico-next)
  	      ("C-k" . vertico-previous))
    :custom
    (vertico-cycle t)
    (vertico-count 10)
    :init
    (vertico-mode))
#+end_src

Useful configuration for emacs
#+begin_src emacs-lisp
  (use-package emacs
  :custom
  ;; Support opening new minibuffers from inside existing minibuffers.
  (enable-recursive-minibuffers t)
  ;; Emacs 28 and newer: Hide commands in M-x which do not work in the current
  ;; mode.  Vertico commands are hidden in normal buffers. This setting is
  ;; useful beyond Vertico.
  (read-extended-command-predicate #'command-completion-default-include-p)
  :init
  ;; Add prompt indicator to `completing-read-multiple'.
  ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
  (defun crm-indicator (args)
    (cons (format "[CRM%s] %s"
                  (replace-regexp-in-string
                   "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                   crm-separator)
                  (car args))
          (cdr args)))
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

  ;; Do not allow the cursor in the minibuffer prompt
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode))
#+end_src


** History
#+begin_src emacs-lisp 
  (use-package savehist
    :init (savehist-mode))
#+end_src


** Orderless
Fuzzy completion matching
#+begin_src emacs-lisp 
  (use-package orderless
    :ensure t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src


** Corfu
Completion mechanism designed to work with Vertico
#+begin_src emacs-lisp
  (use-package corfu
    :ensure t
    :custom
    (corfu-cycle t)  ;; Enable cycling for `corfu-next' and `corfu-previous'.
    (corfu-auto t)  ;; Enable auto completion.
    (corfu-auto-prefix 2)
    (corfu-auto-delay 0.2)
    :bind (:map corfu-map
            ("TAB" . corfu-next)
            ([tab] . corfu-next)
            ("S-TAB" . corfu-previous)
            ([backtab] . corfu-previous))
    :init
    (global-corfu-mode)
    (corfu-history-mode))

  (use-package emacs
    :custom
    (tab-always-indent 'complete))

  (use-package dabbrev
    ;; Swap M-/ and C-M-/
    :bind (("M-/" . dabbrev-completion)
           ("C-M-/" . dabbrev-expand))
    :config
    (add-to-list 'dabbrev-ignored-buffer-regexps "\\` ")
    (add-to-list 'dabbrev-ignored-buffer-modes 'doc-view-mode)
    (add-to-list 'dabbrev-ignored-buffer-modes 'pdf-view-mode)
    (add-to-list 'dabbrev-ignored-buffer-modes 'tags-table-mode))
#+end_src


** Marginalia
Allows for more information for vertico buffers
#+begin_src emacs-lisp 
  (use-package marginalia
    :after vertico
    :ensure t
    :custom 
      (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
    :init
    (marginalia-mode))
#+end_src


* Look and Feel
** Icons
Icon Support. Use nerd icons for maximum terminal goodness!!!
#+begin_src emacs-lisp
  (use-package nerd-icons)

  (use-package nerd-icons-completion
    :config
    (nerd-icons-completion-mode))

  (use-package nerd-icons-dired
    :hook (dired-mode . nerd-icons-dired-mode))
#+end_src

#+end_src


** Theme
Doom Theming
#+begin_src emacs-lisp
  (use-package doom-themes
    :config
    (load-theme 'doom-horizon t))

  (use-package emacs
    :init
    (menu-bar-mode -1)
    (tool-bar-mode -1)
    (scroll-bar-mode -1)
    :custom
    (inhibit-startup-message t))
#+end_src

** Dashboard
Main landing page. Works great with other packages like recentf, org agenda, and projectile. Supplies shortcuts to recent and popular files.
#+begin_src emacs-lisp
  (use-package dashboard
    :ensure t
    :config
    (dashboard-setup-startup-hook)
    :custom
    (initial-buffer-choice (lambda () (get-buffer-create dashboard-buffer-name))) ;; open dashboard for emacs clients
    (dashboard-center-content t)
    (dashboard-vertically-center-content t)
    (dashboard-items '((recents . 8)
  		     (bookmarks . 5)
  		     (projects . 5)
  		     (agenda . 5)))
    (dashboard-navigation-cycle t) ;; cycle through nav headers
    ;; dashboard icons
    (dashboard-display-icons-p t)
    (dashboard-icon-type 'nerd-icons)
    (dashboard-set-heading-icons t)
    (dashboard-set-file-icons t)
    (dashboard-projects-backend 'projectile)
    )
#+end_src

** Doom Modeline
Better looking modeline. The modeline is the bottom bar of emacs and really determines the look and feel of your Emacs setup. There is also a powerline port that is popular as well.
#+begin_src emacs-lisp
    (use-package doom-modeline
      :init
      (doom-modeline-mode 1))
#+end_src

** Font Config
Font config. I am using Fira Code mostly for ligature support, but I recently discovered that there is no italic variant of the font to apply to comments. Standard ligature.el setup here as well.
#+begin_src emacs-lisp
  (use-package emacs
    :config
    (set-face-attribute 'default nil :font "FiraCode Nerd Font" :height 120))

  ;; ligature support
  (use-package ligature
    :config  ;; Enable the "www" ligature in every possible major mode
    (ligature-set-ligatures 't '("www"))
    ;; Enable all Cascadia Code ligatures in programming modes
    (ligature-set-ligatures 'prog-mode '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                                       ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                                       "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                                       "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                                       "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                                       "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                                       "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                                       "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                                       ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                                       "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                                       "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                                       "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                                       "\\\\" "://"))
    (global-ligature-mode))
#+end_src


** Rainbow Delimiters
Applies rainbow effect to delimiters and groups to sort out nesting errors. This is especially useful when working in lisp-like languages.
#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src


* Organization
#+begin_src emacs-lisp
  (use-package recentf
    :init
  	(recentf-mode 1))
#+end_src


* Misc
#+begin_src emacs-lisp
  (use-package emacs
    :config
    (save-place-mode 1)
    (global-auto-revert-mode 1) ;; Revert buffers if file is edited outside of emacs instance
    :custom
    (backup-directory-alist `(("." . "~/.temp"))
          backup-by-copying t))
#+end_src


* Development
** Magit
Git wrapper/client/porcelain for Emacs. Works great with evil-collection.
#+begin_src emacs-lisp
  (use-package magit
    :config
    (nj/leader-keys
      "g" '(:ignore t :wk "git")
      "g s" '(magit-status :wk "magit status")))
#+end_src


** Projectile
Tool for project management. Used to grep projects, find files in projects, and much more. I am only scratching the surface here.
#+begin_src emacs-lisp
  (use-package project) ;; needed for fix with eglot
    
  (use-package projectile
    :diminish
    :config (projectile-mode 1)
    (nj/leader-keys ;; keybinds
      "p" '(projectile-command-map :wk "projectile"))
    (setq projectile-project-search-path '("~/projects/")))
#+end_src


** Tree-Sitter
Excellent tool for parsing grammars. Built into emacs, used for syntax highlighting and extensible language modes.
#+begin_src emacs-lisp
  (use-package tree-sitter
    :ensure t
    :hook
    (tree-sitter-after-on-hook . tree-sitter-hl-mode)
    :init
    (global-tree-sitter-mode))
  ;; install langs
  (use-package tree-sitter-langs
    :ensure t)
#+end_src


** Tweaks
#+begin_src emacs-lisp
  (use-package emacs
    :hook
    (prog-mode . electric-pair-mode)
    (prog-mode . electric-quote-mode))
#+end_src

** Languages
*** EMCA
#+begin_src emacs-lisp
  (use-package tree-sitter
    :mode
    ("\\.ts\\'" . typescript-ts-mode)
    ("\\.tsx\\'" . tsx-ts-mode)
    ("\\.js\\'" . js-ts-mode)
    ("\\.jsx\\'" . tsx-ts-mode))

  (use-package eglot
    :hook
    (tsx-ts-mode . eglot-ensure)
    (typescript-ts-mode . eglot-ensure))
#+end_src

**** Deno
Enable deno lsp with eglot; taken from deno documentation
#+begin_src emacs-lisp
  (use-package eglot
    :config
    (add-to-list 'eglot-server-programs '((js-mode typescript-mode) . (eglot-deno "deno" "lsp")))

    (defclass eglot-deno (eglot-lsp-server) ()
      :documentation "A custom class for deno lsp.")

    (cl-defmethod eglot-initialization-options ((server eglot-deno))
      "Passes through required deno initialization options"
      (list :enable t
	    :lint t)))
#+end_src


*** Nix
Use nix tree sitter mode, as well as setup nil, a Language Server for Nix.
#+begin_src emacs-lisp
  (use-package nix-ts-mode
    :mode "\\.nix\\'")

  (use-package eglot
    :config
    (add-to-list 'eglot-server-programs '(nix-ts-mode . ("nil")))
    :hook
    (nix-ts-mode . eglot-ensure))
#+end_src


** Formating
Alpheleia is a package designed to hook into multiple code formating tools such as Prettier. It executes bash scripts to launch the formatters, so make sure they are properly installed and in the PATH.
#+begin_src emacs-lisp
  (use-package apheleia
    :init
    (setq-default indent-tabs-mode nil)
    (apheleia-global-mode +1))
#+end_src

** Yasnippet
Snippet manager for emacs
#+begin_src emacs-lisp
  (use-package yasnippet
    :config
    (add-to-list 'yas-snippet-dirs "~/.emacs.d/snippets"))
#+end_src


* Org Mode
The ever powerful
#+begin_src emacs-lisp
  (use-package org
    :config
    (require 'org-tempo)
    (nj/leader-keys
      "o" '(:ignore t :wk "org")
      "o e" '(org-edit-special :wk "edit")))
#+end_src

** [[https://orgmode.org/manual/Agenda-Views.html][Agenda]]
Org agenda provides a quick and extensible way to view your scheduled task. It can be configured with custom commands or even extended via a query language like org-ql. Tagging comes in useful here.
#+begin_src emacs-lisp
  (defun org-set-agenda-files-recursively (dirs)
    "Set org agenda files recursively from a list of DIRS."
    (setq org-agenda-files
          (apply 'append ;; make resulting lists of lists into one list
                 (mapcar (lambda (dir) ;; map input list of dirs
                           (directory-files-recursively dir "\.org$"))
                         dirs))))

  (use-package org
    :config
    (nj/leader-keys
      "o a" '(org-agenda :wk "agenda"))
    (org-set-agenda-files-recursively '("~/projects/" "~/org/"))
    :custom
    (org-agenda-custom-commands
     '(("p" "Planning"
        ((tags-todo "+@planning"
                    ((org-agenda-overriding-header "Planning Tasks")))
         (tags-todo "-{.*}"
                    ((org-agenda-overriding-header "Untagged Tasks")))))

       ("i" "Inbox"
        ((todo ""
               ((org-agenda-files '("~/org/inbox.org"))
                (org-agenda-overriding-header "Unprocessed Inbox Items")))))

       ("N" "Search" search ""))))
#+end_src

** Archive
Setup a global archive for completed agenda tasks. This has the benefit of being 
#+begin_src emacs-lisp
  (use-package org
    :custom
    (org-archive-address "~/org/archive.org::%s"))
#+end_src


** [[https://orgmode.org/manual/Capture.html][Capture]]
Captures provide an easy way of intelligently capturing thoughts, tasks, references, and more. Custom capture templates are an awesome way to leverage org, you can find plenty of examples on the Org Mode Wiki.
#+begin_src emacs-lisp
  (use-package org
    :config
    (nj/leader-keys
      "o c" '(org-capture :wk "capture"))
    :custom
    (org-capture-templates
     '(("t" "Todo" entry
        (file "~/org/inbox.org")
        "* TODO %?"))))
#+end_src

** Refile
Refiling allows easy migration of any Org item to a specific header.
#+begin_src emacs-lisp
  (use-package org
    :config
    (nj/leader-keys
      "o r f" '(org-refile-in-file :wk "refile in file")
      "o r a" '(org-refile-in-agenda :wk "refile in agenda file")))
#+end_src

*** Refile in Current Buffer/Org File
This is defualt functionality
#+begin_src emacs-lisp
  (defun org-refile-in-file ()
    "Refile item inside current org file"
    (interactive)
    (setq org-refile-targets nil)
    (org-refile))
#+end_src

*** Refile in Org Agenda File
Used for refiling tasks to agenda files
#+begin_src emacs-lisp
  (defun org-refile-in-agenda ()
    "Refile item inside org agenda file"
    (interactive)
    (setq org-refile-targets '((org-agenda-files :maxlevel . 3)))
    (org-refile))
#+end_src


** Tags
Tags are a great way to sort headings, but more applicably todos, by type to quickly poll for them in an agenda view. Common tags can be a defined and easily applied on any Org Item by using org-set-tag-command anf the defined hotkey.
#+begin_src emacs-lisp
  (use-package org
    :config
    (nj/leader-keys
      "o q" '(org-set-tags-command :wk "set tags"))
    :custom
    (org-tag-alist
     '(
       ;; Settings
       ("@home" . "?H")
       ("@work" ."?W")
       ("@car" . "?A")

       ;; Devices
       ("@computer" . "?C")
       ("@phone" . "?P")
       ("@server" . "?S")

       ;; Task Types
       ("@planning" . "?p")
       ("@development" . "?d")
       ("@errands" . "?r")
       ("@service" . "?s")
       ("@creative" . "?c")

       ;; Events
       ("@birthday" . "?B")
       ("@wedding" . "?W")
       ("@anniversary" . "?V")
       )))
#+end_src


** [[https://orgmode.org/manual/TODO-Extensions.html][Todos]]
Todos can be defined with custom states using org todo keywords, the pipe delimiter seperates TODO type tasks from DONE type ones.
You can also assign hotkeys to todo types as well, which will change the functionality from cycling to direct toggling.
#+begin_src emacs-lisp
  (use-package org
    :config
    (nj/leader-keys
      "o t" '(org-todo :wk "todo"))
    :custom
    (org-todo-keywords '((sequence "TODO(t)" "ACTIVE(a)" "WAITING(w)" "|" "DONE(d)"))))
#+end_src


** Auto Tangle
Allows for any literate programming projects to auto tangle all source blocks on save.
To have an org mode buffer tangle at save, you must define auto_tangle: t in the header args. This can come back to bite you, as sometimes saving my commit a mistake unknowingly.
#+begin_src emacs-lisp
  (use-package org-auto-tangle
    :defer t
    :hook (org-mode . org-auto-tangle-mode))
#+end_src


** Bullets
Replace standard * headers with defined unicode bullets
#+begin_src emacs-lisp
  (use-package org-bullets
    :hook (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '("◉" "○" "●" "○" "●" "○" "●")))
#+end_src

