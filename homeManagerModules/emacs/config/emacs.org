#+TITLE: New Emacs Config
#+AUTO_TANGLE: t
#+PROPERTY: header-args:emacs-lisp :tangle ./init.el 
* Early Init
Set early init vars for straight.el
#+begin_src emacs-lisp :tangle ./early-init.el
(setq package-enable-at-startup nil)
#+end_src


* Package Management
Package Management via straight.el
#+begin_src emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name
      	"straight/repos/straight.el/bootstrap.el"
    	(or (bound-and-true-p straight-base-dir)
  	    user-emacs-directory)))
        (bootstrap-version 7))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
  	(url-retrieve-synchronously
  	 "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
  	 'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

  ;; Set up use-package to use straight.el
  (straight-use-package 'use-package)
  (setq straight-use-package-by-default t)
#+end_src


* Evil Mode
Vi emulation layer. Adds vim emulation to emacs in all programming and text editing buffers. Evil collection is a collection of keybind packages designed to integrate vim keybinds into popular emacs packages such as magit.
#+begin_src emacs-lisp
  (use-package evil
    :hook ((prog-mode text-mode) . display-line-numbers-mode)
    :custom
    (display-line-numbers-type 'relative)
    (evil-want-integration t)
    (evil-want-keybinding nil)
    (evil-want-C-i-jump nil)
    (evil-respect-visual-line-mode t)
    (evil-want-Y-yank-to-eol t)
    :init
    (global-visual-line-mode)
    (evil-mode))

  ;; Keybind collection for evil
  (use-package evil-collection
    :after evil
    :config
    (evil-collection-init))
#+end_src

** Undo/Redo
Implement undo redo for evil using undofu. This allows for undo branching and branch hopping if need be.
#+begin_src emacs-lisp
  (use-package evil
    :custom
    (evil-undo-system 'undo-fu))

  (use-package undo-fu
    :custom
    (undo-limit 67108864)
    (undo-strong-limit 100663296)
    (undo-outer-limit 1006632960))
#+end_src


* Keybinds
** General
Leader key definition and easy keybinds. I have defined a lot of various keybinds here that I donâ€™t think belong anywhere else.
#+begin_src emacs-lisp
  (use-package general
    :config
    (general-evil-setup)

    (general-create-definer nj/leader-keys
      :states '(normal insert visual emacs)
      :keymaps 'override
      :prefix "SPC"
      :global-prefix "C-SPC")

    (nj/leader-keys
      "/" '(find-file :wk "goto file")
      ">" '(:ignore t :wk "goto")
      "> r" '(recentf :wk "goto recent file")
      "> m" '(bookmark :wk "goto bookmark")
      "f" '(:ignore t :wk "find")
      "f f" '(find-file :wk "find file")
      "f r" '(recentf :wk "find recent")
      "f m" '(bookmark :wk "find bookmark")
      "x" '(execute-extended-command :wk "M-x")
      "C-/" '(comment-line :wk "comment lines"))

    (nj/leader-keys
      "TAB" '(evil-window-next :wk "next window"))

    ;; buffer keybinds
    (nj/leader-keys
      "b" '(:ignore t :wk "buffer")
      "b b" '(counsel-switch-buffer :wk "switch to buffer")
      "b i" '(ibuffer :wk "ibuffer")
      "b k" '(kill-this-buffer :wk "kill buffer")
      "b n" '(next-buffer :wk "next buffer")
      "b p" '(previous-buffer :wk "previous buffer")
      "b r" '(revert-buffer :wk "reload buffer"))

    ;; bookmarks
    (nj/leader-keys
      "m" '(:ignore t :wk "bookmarks")
      "m d" '(bookmark-delete :wk "delete bookmark")
      "m l" '(bookmark-bmenu-list :wk "bookmark list")
      "m m" '(bookmark-set :wk "add bookmark")
      "m M" '(bookmark-set-no-overwrite :wk "add permanent bookmark"))) 
#+end_src

** Which-Key
Keybind tooltips
#+begin_src emacs-lisp
    (use-package which-key
      :diminish
      :init
      (which-key-mode 1)
      :custom
      (which-key-idle-delay 0.8)
      (which-key-allow-imprecise-window-fit nil))
#+end_src


* Completion
** Vertico
Completion interface, replacement for Ivy
#+begin_src emacs-lisp 
  (use-package vertico
    :ensure t
    :bind (:map vertico-map
  	      ("C-j" . vertico-next)
  	      ("C-k" . vertico-previous)
                ("<tab>" . vertico-insert))
    :custom
    (vertico-cycle t)
    (vertico-count 10)
    (vertico resize t)
    :init
    (vertico-mode))
#+end_src

Useful configuration for emacs
#+begin_src emacs-lisp
  (use-package emacs
  :custom
  ;; Support opening new minibuffers from inside existing minibuffers.
  (enable-recursive-minibuffers t)
  ;; Emacs 28 and newer: Hide commands in M-x which do not work in the current
  ;; mode.  Vertico commands are hidden in normal buffers. This setting is
  ;; useful beyond Vertico.
  (read-extended-command-predicate #'command-completion-default-include-p)
  (read-file-name-completion-ignore-case t)
  (read-buffer-completion-ignore-case t)
  (completion-ignore-case t)
  :init
  ;; Add prompt indicator to `completing-read-multiple'.
  ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
  (defun crm-indicator (args)
    (cons (format "[CRM%s] %s"
                  (replace-regexp-in-string
                   "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                   crm-separator)
                  (car args))
          (cdr args)))
  (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

  ;; Do not allow the cursor in the minibuffer prompt
  (setq minibuffer-prompt-properties
        '(read-only t cursor-intangible t face minibuffer-prompt))
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode))
#+end_src


** History
#+begin_src emacs-lisp 
  (use-package savehist
    :init (savehist-mode))
#+end_src


** Orderless
Fuzzy completion matching
#+begin_src emacs-lisp 
  (use-package orderless
    :ensure t
    :custom
    (completion-styles '(orderless basic))
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src


** Corfu
Completion mechanism designed to work with Vertico
#+begin_src emacs-lisp
  (use-package corfu
    :ensure t
    :custom
    (corfu-cycle t)  ;; Enable cycling for `corfu-next' and `corfu-previous'.
    (corfu-auto t)  ;; Enable auto completion.
    (corfu-auto-prefix 2)
    (corfu-auto-delay 0)
    :bind (:map corfu-map
            ("TAB" . corfu-next)
            ([tab] . corfu-next)
            ("S-TAB" . corfu-previous)
            ([backtab] . corfu-previous))
    :init
    (global-corfu-mode)
    (corfu-history-mode))

  (use-package emacs
    :custom
    (tab-always-indent 'complete))

  (use-package dabbrev
    ;; Swap M-/ and C-M-/
    :bind (("M-/" . dabbrev-completion)
           ("C-M-/" . dabbrev-expand))
    :config
    (add-to-list 'dabbrev-ignored-buffer-regexps "\\` ")
    (add-to-list 'dabbrev-ignored-buffer-modes 'doc-view-mode)
    (add-to-list 'dabbrev-ignored-buffer-modes 'pdf-view-mode)
    (add-to-list 'dabbrev-ignored-buffer-modes 'tags-table-mode))
#+end_src


** Marginalia
Allows for more information for vertico buffers
#+begin_src emacs-lisp 
  (use-package marginalia
    :after vertico
    :ensure t
    :custom 
    (marginalia-align 'right)
    (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil))
    :init
    (marginalia-mode))
#+end_src


* Look and Feel
** Icons
Icon Support. Use nerd icons for maximum terminal goodness!!!
#+begin_src emacs-lisp
  (use-package nerd-icons)

  (use-package nerd-icons-completion
    :config
    (nerd-icons-completion-mode))

  (use-package nerd-icons-dired
    :hook (dired-mode . nerd-icons-dired-mode))
#+end_src

#+end_src


** Theme
Doom Theming
#+begin_src emacs-lisp
  (use-package doom-themes
    :config
    (load-theme 'doom-tokyo-night t))

  (use-package emacs
    :init
    (menu-bar-mode -1)
    (tool-bar-mode -1)
    (scroll-bar-mode -1)
    :custom
    (scroll-margin 6)
    (scroll-conservatively 40)
    (inhibit-startup-message t))
#+end_src


** Dashboard
Main landing page. Works great with other packages like recentf, org agenda, and projectile. Supplies shortcuts to recent and popular files.
#+begin_src emacs-lisp
  (use-package dashboard
    :ensure t
    :config
    (dashboard-setup-startup-hook)
    :custom
    (initial-buffer-choice (lambda () (get-buffer-create dashboard-buffer-name))) ;; open dashboard for emacs clients
    (dashboard-center-content t)
    (dashboard-vertically-center-content t)
    (dashboard-items '((recents . 8)
  		     (bookmarks . 5)
  		     (projects . 5)
  		     (agenda . 5)))
    (dashboard-navigation-cycle t) ;; cycle through nav headers
    ;; dashboard icons
    (dashboard-display-icons-p t)
    (dashboard-icon-type 'nerd-icons)
    (dashboard-set-heading-icons t)
    (dashboard-set-file-icons t)
    (dashboard-projects-backend 'projectile)
    )
#+end_src


** Doom Modeline
Better looking modeline. The modeline is the bottom bar of emacs and really determines the look and feel of your Emacs setup. There is also a powerline port that is popular as well.
#+begin_src emacs-lisp
  (use-package doom-modeline
    :custom
    (doom-modeline-total-line-number t)
    :init
    (doom-modeline-mode 1))
#+end_src


** Font Config
Font config. I am using Fira Code mostly for ligature support, but I recently discovered that there is no italic variant of the font to apply to comments. Standard ligature.el setup here as well.
#+begin_src emacs-lisp
  (use-package emacs
    :config
    (set-face-attribute 'default nil :font "FiraCode Nerd Font" :height 120))

  ;; ligature support
  (use-package ligature
    :config  ;; Enable the "www" ligature in every possible major mode
    (ligature-set-ligatures 't '("www"))
    ;; Enable all Cascadia Code ligatures in programming modes
    (ligature-set-ligatures 'prog-mode '("|||>" "<|||" "<==>" "<!--" "####" "~~>" "***" "||=" "||>"
                                       ":::" "::=" "=:=" "===" "==>" "=!=" "=>>" "=<<" "=/=" "!=="
                                       "!!." ">=>" ">>=" ">>>" ">>-" ">->" "->>" "-->" "---" "-<<"
                                       "<~~" "<~>" "<*>" "<||" "<|>" "<$>" "<==" "<=>" "<=<" "<->"
                                       "<--" "<-<" "<<=" "<<-" "<<<" "<+>" "</>" "###" "#_(" "..<"
                                       "..." "+++" "/==" "///" "_|_" "www" "&&" "^=" "~~" "~@" "~="
                                       "~>" "~-" "**" "*>" "*/" "||" "|}" "|]" "|=" "|>" "|-" "{|"
                                       "[|" "]#" "::" ":=" ":>" ":<" "$>" "==" "=>" "!=" "!!" ">:"
                                       ">=" ">>" ">-" "-~" "-|" "->" "--" "-<" "<~" "<*" "<|" "<:"
                                       "<$" "<=" "<>" "<-" "<<" "<+" "</" "#{" "#[" "#:" "#=" "#!"
                                       "##" "#(" "#?" "#_" "%%" ".=" ".-" ".." ".?" "+>" "++" "?:"
                                       "?=" "?." "??" ";;" "/*" "/=" "/>" "//" "__" "~~" "(*" "*)"
                                       "\\\\" "://"))
    (global-ligature-mode))
#+end_src


** Rainbow Delimiters
Applies rainbow effect to delimiters and groups to sort out nesting errors. This is especially useful when working in lisp-like languages.
#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src


* Organization
#+begin_src emacs-lisp
  (use-package recentf
    :init
    (recentf-mode 1))
#+end_src


* Misc
#+begin_src emacs-lisp
  (use-package emacs
    :config
    (save-place-mode 1)
    (global-auto-revert-mode 1) ;; Revert buffers if file is edited outside of emacs instance
    :custom
    (backup-directory-alist `(("." . "~/.temp"))
          backup-by-copying t))
#+end_src


* Development
** Magit
Git wrapper/client/porcelain for Emacs. Works great with evil-collection.
#+begin_src emacs-lisp
  (use-package magit
    :config
    (nj/leader-keys
      "g" '(:ignore t :wk "git")
      "g s" '(magit-status :wk "magit status")))
#+end_src


** Projectile
Tool for project management. Used to grep projects, find files in projects, and much more. I am only scratching the surface here.
#+begin_src emacs-lisp
  (use-package project) ;; needed for fix with eglot
    
  (use-package projectile
    :diminish
    :config (projectile-mode 1)
    (nj/leader-keys ;; keybinds
      "p" '(projectile-command-map :wk "projectile"))
    (setq projectile-project-search-path '("~/projects/")))

  (use-package rg) ;; ripgrep for use with projectile
#+end_src


** Treemacs
Directory tree view, akin to vscode
#+begin_src emacs-lisp
  (use-package treemacs)
  (use-package treemacs-evil)
  (use-package treemacs-nerd-icons
    :config
    (treemacs-load-theme "nerd-icons"))
#+end_src

** Tree-Sitter
Excellent tool for parsing grammars. Built into emacs, used for syntax highlighting and extensible language modes.
#+begin_src emacs-lisp
  (use-package tree-sitter
    :ensure t
    :hook
    (tree-sitter-after-on-hook . tree-sitter-hl-mode)
    :init
    (global-tree-sitter-mode))
  ;; install langs
  (use-package tree-sitter-langs
    :ensure t)
#+end_src


** Tweaks
#+begin_src emacs-lisp
  (use-package emacs
    :hook
    (prog-mode . electric-pair-mode)
    (prog-mode . electric-quote-mode))
#+end_src


** Languages
*** EMCA
#+begin_src emacs-lisp
  (use-package tree-sitter
    :mode
    ("\\.ts\\'" . typescript-ts-mode)
    ("\\.tsx\\'" . tsx-ts-mode)
    ("\\.js\\'" . js-ts-mode)
    ("\\.jsx\\'" . tsx-ts-mode))

  ;; (use-package eglot
  ;;   :hook
  ;;   (tsx-ts-mode . eglot-ensure)
  ;;   (typescript-ts-mode . eglot-ensure))
#+end_src

**** Deno
Enable deno lsp with eglot; taken from deno documentation
#+begin_src emacs-lisp
  (use-package eglot
    :config
    (add-to-list 'eglot-server-programs '((js-ts-mode typescript-ts-mode) . (eglot-deno "deno" "lsp")))

    (defclass eglot-deno (eglot-lsp-server) ()
      :documentation "A custom class for deno lsp.")

    (cl-defmethod eglot-initialization-options ((server eglot-deno))
      "Passes through required deno initialization options"
      (list :enable t
	    :lint t)))
#+end_src


*** Nix
Use nix tree sitter mode, as well as setup nil, a Language Server for Nix.
#+begin_src emacs-lisp
  (use-package nix-ts-mode
    :mode "\\.nix\\'")

  (use-package eglot
    :config
    (add-to-list 'eglot-server-programs '(nix-ts-mode . ("nil")))
    :hook
    (nix-ts-mode . eglot-ensure))
#+end_src


** Formating
Alpheleia is a package designed to hook into multiple code formating tools such as Prettier. It executes bash scripts to launch the formatters, so make sure they are properly installed and in the PATH.
#+begin_src emacs-lisp
  (use-package apheleia
    :init
    (setq-default indent-tabs-mode nil)
    (apheleia-global-mode +1))
#+end_src


** Yasnippet
Snippet manager for emacs
#+begin_src emacs-lisp
  (use-package yasnippet
    :config
    (add-to-list 'yas-snippet-dirs "~/.emacs.d/snippets"))
#+end_src


* Org Mode
The ever powerful
#+begin_src emacs-lisp
  (use-package org
    :hook (org-mode . org-indent-mode)
    :config
    (require 'org-tempo)
    (nj/leader-keys
      "o" '(:ignore t :wk "org")
      "o e" '(org-edit-special :wk "edit")))

  (use-package org-modern
    :hook (org-mode . org-modern-mode)
    :custom
    (org-modern-todo nil)
    (org-modern-tag nil)
    (org-modern-timestamp nil)
    (org-modern-star 'replace))
#+end_src

** [[https://orgmode.org/manual/Agenda-Views.html][Agenda]]
Org agenda provides a quick and extensible way to view your scheduled task. It can be configured with custom commands or even extended via a query language like org-ql. Tagging comes in useful here.
#+begin_src emacs-lisp
  (use-package org
    :config
    (nj/leader-keys
      "o a" '(org-agenda :wk "agenda"))
    :custom
    (org-agenda-files (directory-files-recursively org-directory "\.org$"))
    (org-agenda-custom-commands
     '(("p" "Planning"
        ((tags-todo "+@planning"
                    ((org-agenda-overriding-header "Planning Tasks")))
         (tags-todo "-{.*}"
                    ((org-agenda-overriding-header "Untagged Tasks")))))

       ("i" "Inbox"
        ((todo ""
               ((org-agenda-files '("~/org/inbox.org"))
                (org-agenda-overriding-header "Unprocessed Inbox Items")))))

       ("P" "Projects"
        ((todo ""
        ((org-agenda-files (directory-files-recursively "~/org/projects" "\.org$")
                           ((org-agenda-overriding-header "Projects")))))))

       ("N" "Search" search ""))))
#+end_src


** Archive
Setup a global archive for completed agenda tasks. This has the benefit of being 
#+begin_src emacs-lisp
    (use-package org
      :config
      (nj/leader-keys
        "o x" '(:ignore t :wk "archive")
        "o x a" '(org-archive-subtree-default :wk "archive default"))
      :custom
      (org-archive-location "~/org/archive.org::* %s"))
#+end_src


** [[https://orgmode.org/manual/Capture.html][Capture]]
Captures provide an easy way of intelligently capturing thoughts, tasks, references, and more. Custom capture templates are an awesome way to leverage org, you can find plenty of examples on the Org Mode Wiki.
#+begin_src emacs-lisp
  (use-package org
    :config
    (nj/leader-keys
      "o c" '(org-capture :wk "capture"))
    :custom
    (org-capture-templates
     '(("t" "Task Entries")
       ("tq" "Quick Task" entry
        (file+olp+datetree "inbox.org")
        "* TODO %^{Task}\n%?")
       ("tr" "Reference Task" entry
        (file+olp+datetree "inbox.org")
        "* TODO %^{Task}\n%A\n%?")

       ("c" "Contact Info")
       ("cF" "Family" entry
        (file+headline "life/contacts.org" "Family")
        "* %^{Name SURNAME}\n :PROPERTIES:\n :RELATIONSHIP: %^{Relationship}\n :PHONE: %^{Number}\n :EMAIL: %^{Email}\n :BORN: %^{Birthday}t\n :END:\n%?")
       )))
#+end_src

** Refile
Refiling allows easy migration of any Org item to a specific header.
#+begin_src emacs-lisp
  (use-package org
    :custom
    (setq org-refile-targets '((org-agenda-files :maxlevel . 3)))
    :config
    (nj/leader-keys
      "o r" '(org-refile :wk "refile")))
#+end_src

** Roam
#+begin_src emacs-lisp
  (use-package org-roam
    :ensure t
    :custom
    (org-roam-directory "~/org/notes")
    :config
    (nj/leader-keys
      "o n" '(:ignore t :wk "org note")
      "o n f" '(org-roam-node-find :wk "org note find")
      "o n i" '(org-roam-node-insert :wk "org note insert")
      )
    (org-roam-setup))

  (use-package org-roam-ui)
#+end_src

** Tags
Tags are a great way to sort headings, but more applicably todos, by type to quickly poll for them in an agenda view. Common tags can be a defined and easily applied on any Org Item by using org-set-tag-command anf the defined hotkey.
#+begin_src emacs-lisp
  (use-package org
    :config
    (nj/leader-keys
      "o q" '(org-set-tags-command :wk "set tags"))
    :custom
    (org-tag-alist
     '(
       ;; Settings
       ("@home" . ?H)
       ("@work" . ?W)
       ("@car" . ?A)

       ;; Devices
       ("@computer" . ?C)
       ("@phone" . ?P)
       ("@server" . ?S)

       ;; Task Types
       ("@planning" . ?p)
       ("@development" . ?d)
       ("@errands" . ?r)
       ("@service" . ?s)
       ("@creative" . ?c)

       ;; Events
       ("@birthday" . ?B)
       ("@wedding" . ?W)
       ("@anniversary" . ?V)
       )))
#+end_src


** [[https://orgmode.org/manual/TODO-Extensions.html][Todos]]
Todos can be defined with custom states using org todo keywords, the pipe delimiter seperates TODO type tasks from DONE type ones. You can also assign hotkeys to todo types as well, which will change the functionality from cycling to direct toggling.
#+begin_src emacs-lisp
    (use-package org
      :config
      (nj/leader-keys
        "o t" '(org-todo :wk "todo"))
      :custom
      (org-todo-keywords '((sequence "TODO(t)" "ACTIVE(a)" "WAITING(w)" "|" "DONE(d)")))
      (org-log-done 'time))
#+end_src


** Auto Tangle
Allows for any literate programming projects to auto tangle all source blocks on save.
To have an org mode buffer tangle at save, you must define auto_tangle: t in the header args. This can come back to bite you, as sometimes saving my commit a mistake unknowingly.
#+begin_src emacs-lisp
  (use-package org-auto-tangle
    :defer t
    :hook (org-mode . org-auto-tangle-mode))
#+end_src


* Open Ai API Client
Client for OpenAI. Major credit to [[https://gist.github.com/Gavinok/a18e0b2dac74e4ae67df35e45a170f7f][Gavin Freeborn]].
#+begin_src emacs-lisp :tangle ./openai.el
  (require 'seq)
  (eval-when-compile
    (require 'cl-lib)
    (require 'subr-x)
    (require 'env)
    (require 'json))

  (defvar openai-buffer "*OpenAI*"
    "Buffer used for OpenAI Responses")

  (defvar openai-model "mistral-small-latest"
    "Buffer used for OpenAI Responses")

  (define-error 'openai-response-error "Response error for OpenAi Package")
  (define-error 'openai-parsing-error "Error parsing response from OpenAi")

    ;;;###autoload
  (defun openai-prompt (prompt callback)
    "Query OpenAI with PROMPT and pass PROMPT and RESPONSE into CALLBACK"
    (interactive (list (read-string "Prompt OpenAI with: ")
                       (lambda (prompt response)
                         (openai-simulate-chat prompt response))))
    (openai--request prompt callback))

  (defun openai--extract-from-query (response)
    "Extract the meat and potatoes from and OpenAI RESPONSE Query"
    (condition-case err
        (let* ((choices (assoc-default 'choices response))
               (first-choice (seq-first choices))
               (message (assoc-default 'message first-choice))
               (content (assoc-default 'content message)))
          (string-trim content)
          content) ;; return content
      (error
       (signal 'openai-parsing-error err))))

  (defun openai--parse-and-handle-response (status prompt callback)
    "Parse the JSON response from the OpenAI API. Ingore STATUS and pass the RESULT and PROMPT to CALLBACK"
    (ignore status)
    (goto-char 0)
    (re-search-forward "^$")
    (let ((json-response (buffer-substring-no-properties (point) (point-max))))
      (condition-case err
          (let ((parsed-response (json-read-from-string json-response)))
            (funcall callback prompt (openai--extract-from-query parsed-response))) ;; return parsed-response
        (error
         (message "JSON Parsing Error: %s" (error-message-string err))))))

  (defun openai--request (prompt callback)
    "Make async request to OpenAI client using PROMPT. The RESPONSE is then parsed for content and handled in CALLBACK."
    (let* ((api-key (getenv "OPENAI_API_KEY"))
           (url-request-method (encode-coding-string "POST" 'us-ascii))
           (url-request-extra-headers `(("Content-Type" . "application/json")
                  		      	      ("Authorization" . ,(format "Bearer %s" api-key))))
           (url-request-data (json-encode
                              `((model . ,openai-model)
                                (messages . [((role . "user") (content . ,prompt))])
                                (max_tokens . 1000) ; You can adjust this as needed
                                (temperature . 0))))) ; Adjusted temperature value
      (cl-assert (not (string= "" api-key))
                 t
                 "Current contents of the environmental variable OPENAI_API_KEY
                  are '%s' which is not an appropriate OpenAI token please ensure
                  you have the correctly set the OPENAI_API_KEY variable"
                 api-key)
      (url-retrieve
       "https://api.mistral.ai/v1/chat/completions"
       'openai--parse-and-handle-response (list prompt callback))))

  (defun openai-simulate-chat (prompt response)
    "Simulates OpenAI Chat Style in dedicated buffer."
    (let ((buf (get-buffer-create openai-buffer)))
      (with-current-buffer buf
        (goto-char (point-max)) ;; goto end of buffer
        (insert "User: " prompt "\n\n" openai-model ": " response "\n\n")
        (help-mode)
        (setq buffer-read-only nil))
      (display-buffer buf)))

  (defvar openai-mode-font-lock-keywords
    '(("\\bUser:\\b"
       (0 'font-lock-bold-face t)
       (1 'font-lock-keyword-face t))
      ("\\bResponse:\\b"
       (0 'font-lock-bold-face t)
       (1 'font-lock-keyword-face t))))

  (defvar openai-mode-map
    (let ((map (make-sparse-keymap)))
      (define-key map (kdb "q") 'delete-window
                  map)))

  (define-derived-mode openai-mode help-mode "OpenAI Mode"
    "Mode for handling OpenAI responses.")

  (provide 'openai)
#+end_src

#+begin_src emacs-lisp 
  (add-to-list 'load-path "~/nix/homeManagerModules/emacs/config/")
  (require 'openai)
#+end_src




